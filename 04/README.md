# Архитектуры мобильных приложений

## Что это вообще такое

Под понятием "архитектура" люди понимают разные вещи. Мы пож этим будем понимать _договоренности по организации кода в приложении_. 

## Зачем это нужно

Часто у новичков (да и не только новичков) возникают вопросы из серии

* А вот этот вот в каком классе писать?
* А где надо обработать эти данные? А вот те?
* Есть похожие компоненты, как бы их поудачнее использовать во всех местах?

Именно на такие вопросы и даёт ответ архитектура. В идеальном мире мы точно знаем, куда именно надо написать тот или иной код, и как именно это сделать.

С другой стороны, когда ты приходишь в новый проект, который до тебя делали другие люди, у тебя часто возникают такие вопросы

* А вот эта штука, она где?
* А этот экран?
* А почему это вот здесь, а не вот здесь?
* и всякие другие подобные

Если при написании придолжения руководствовались какой-то архитектурой — ответы на большинтство этих вопросов уже есть. Потому что архитектура это _набор договоренностей_.

## Какие они бывают?

### MVC

_классика, не прошедшая проверку временем_

####Model

Модель и бизнес-логика. Содержит как данные, так и логика по работе с этими данными.

####View

Отображение. То, как данные показываются пользователю и интеракция пользователя с этими данными.

####Controller

Координатор действий для view и model. 



Основная проблема в этой архитектуре это то, что контроллеры становятся своего рода god-object, управляют всем и вся, разрастаются в размерах и достаточно быстро это всё становится не то чтобы очень поддерживаемым.

Другая проблема в том, что, как правило, никто не придерживается принципов **SOLID** когда пишет по MVC и от этого код получается не то чтобы очень простым. 

### MVVM

_неплохо, но есть и лучше_

####Model

Всё так же, как в MVC, данные и логика работы с ними.

####View

Отображение данных, но не тупое, как в MVC, а активное, которое умеет получать от ViewModel сигналы и обрабатываться их, так же, как и посылать свои сигналы в ViewModel.

####ViewModel

с одной стороны, абстракция Представления, а с другой — обёртка данных из Модели, подлежащие связыванию. То есть, она содержит Модель, преобразованную к Представлению, а также команды, которыми может пользоваться Представление, чтобы влиять на Модель.

### VIPER

_рабочая лошадка_

#### View

Просто тупое отображение

#### Interactor

Работа с внешними сервисами, типа сети, аналитики и т.д.

####Presenter

Бизнес логика. Делает запросы в interactor, обновляет view, делает переходы через router

####Entity

POSO (PONSO) модели данных. Чисто данные и ничего больше.

####Router

Штука, которая обрабатывает переходы из одного модуля в другой

## Какая лучшая?

Лучшей не существует. Каждая подходит для каждого конкретного случая. Самое главное — ***ЛЮБАЯ*** лучше, чем её отсутствие.

## S.O.L.I.D.

Даже когда у нас есть архитектура, для того, чтобы писать хороший код нам всё равно надо придерживаться более низкоуровневых принципов. Главный принцип это SOLID. Оно расшифровывается вот так

### Single responsibility

Приницп одной ответственности. Класс должен делать одну вещь, и только одну.

###Open/Closed

Классы должны быть закрыты для модификаций, но открыты для расширения.

###Liskov's substitution

Наследующие классы должны расширять, а не изменять поведение базового класса. Или, другими словами, при передаче куда-то наследника класса, описанного в контракте, поведение системы в целом меняться не должно.

###Interface segregation

Много интерфейсов для клиента лучше, чем один общий. То есть не надо пытаться описать в одном интерфейсе всё на свете, лучше сделать много интерфейсов.

###Dependency inversion

Зависимости должны быть от абстракций, не от конкретных реализаций. Зависимости должны идти снизу вверх, а не сверху вниз. View может зависеть от model, а вот model от view — никогда.

## Ссылки

### Архитектуры

- VIPER 
  - https://github.com/strongself/The-Book-of-VIPER
  - https://www.objc.io/issues/13-architecture/viper/
- YARCH
  - https://github.com/alfa-laboratory/YARCH